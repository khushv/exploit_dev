; inspired by egghunting, will print memory addresses for valid page frames
; http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf
; https://skiponacci.github.io/slae-assignment-3/


global _start

section .text

_start:

	xor ecx, ecx		; clear ecx, eax, and edx
	mul ecx

Page_align:
	or dx, 0xfff		; increase edx to page_size 0x1000 or 4096 bytes
Incpage:
	inc edx				; load address 4 bytes past edx into ebx
	lea ebx, [edx+0x4]	; compare ebx and [edx+4] (8 bytes) at the same time
	push byte +0x21		; access() syscall # 
	pop eax			; pop 0x21 into eax, saves a byte over xor
	int 0x80		; run access() which checks memory location of edx
	cmp al, 0xf2		; compare eax with efault value, did we get an efault?
	jz Page_align		; yes = go back and increment the page to start again
	pushad	
	
	mov edx, ebx
	;mov edx,0x1234567
	
Translate: 
	;mov edi, address	
	;mov eax, 0xa
	;stosb
	push 0xa	

	xor ebx, ebx
    mov  ecx, 0x04          ; set loop counter to bytes in buffer
Begin:     
    mov al, dl
    mov   ah, al          ; duplicate
    shr   al, 0x04        ; high nibble to low sibble
    and   ax, 0x0f0f      ; mask out high nibbles
                          ; high nibble is now in low 4 of al
                          ; low  niblle is in low 4 of ah
    or    ax, 0x3030      ; shift code bank
    cmp   al, 0x39        ; if high nibble > '9'
    jbe   Skip1
    add   al, 0x07        ; adjust to alphabetic
Skip1:     
    cmp   ah, 0x39        ; if low  nibble > '9'
    jbe   Skip2           ;
    add   ah, 0x07        ; adjust to alphabetic
Skip2:     
    push ax 
    shr edx, 0x08
    loop  Begin           ; repeat while bytes remain.
	mov eax, 0x04
    mov ebx, 0x01
    mov ecx, esp 
    mov edx, 0x0b 		; print 11 chars 
    int 0x80
	add esp,8		; remove 8 bytes
	popad
	jmp Page_align 

section .data 
	egg db 0x50,0x40,0x50,0x40,0x50,0x40,0x50,0x40,0x90

