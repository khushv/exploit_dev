#!/usr/bin/python


import argparse

from binascii import hexlify
from struct import pack
from sys import argv
from pwnlib.asm import asm

good = ['\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\x08', '\t', '\x0b', '\x0c', '\x0e', '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!', '"', '#', '$', '%', '&', "'", '(', ')', '*', '+', ',', '-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ';', '<', '=', '>', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f']

good = ['\x01', '\x02', '\x03', '\x04', '\x05', '\x06', '\x07', '\x08', '\t', '\x0b', '\x0c', '\x0e', '\x0f', '\x10', '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18', '\x19', '\x1a', '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!', '"', '#', '$', '%', '&', "'", '(', ')', '*', '+', ',', '-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ';', '<', '=', '>', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f']


register = 'eax'

def convert_line(line):
    line = line[::-1]
    hexlify_str = hexlify(line)
    in_hex = int(hexlify_str, 16)
    sub_value = hex(0x100000000 - in_hex)[2:]
    while len(sub_value) < 8:
        sub_value = "0" + sub_value
    sub_value = "0x" + sub_value   
    return sub_value

def generate_good_dict():
    good_dict = []
    for value in good:
        good_dict.append(ord(value))
    return good_dict


def locate_two(token): # expects hex string
    left, right = [], []
    for i in good:
        for j in good:
            if (i+j) == token:
                left.append(i)
                right.append(j)
    if len(left) == 1:
        return [left[0], right[0]]
    elif len(left) >= 2:
        dividor = len(left) // 2
        return [left[dividor], right[dividor]]
    return None


def pre_process(address):
    # print("[*] Tackling address: {}".format(address))
    one, two, three = [], [], []
    address = address[2:]
    split = [(address[i:i+2]) for i in range(0, len(address), 2)]
    split.reverse()
    overflow = -1
    for i in range(0, 4):
        char = split[i]
        char = int(char, 16)
        # print("[*] ** Checking {} position, with value {} ***".format(i, char))
        if i >= 1 and (overflow == i-1):
            # print("[*] *** Overflow detected at {}, adding 1 to current number".format(overflow))
            char -= 1  
        result = locate_two(char)
        if result:
            one.append(result[0])
            two.append(result[1])
            three.append(0)
        else:
            # print("[*] ***** Attempting second location for char {}".format(char))
            for good_char in good:
                leftover = char - good_char    # in decimal
                # print("[*] Leftover initially is {}".format(leftover))
                if leftover == 0:
                    # print("[*] Landed on 0")
                    overflow = i
                    leftover = 256 + char- abs(good_char)
                if leftover < 0:
                    # print("[*] Landed on less than zero")
                    overflow = i
                    leftover = 256 + char - abs(good_char) 
                    #print("[*] *******  Overflow detected at {}".format(overflow))
                #print("[*] ********* Leftover is now {}".format(leftover))
                leftover_in_hex = hex(leftover)
                # print("[*] ********** Attempting second location after subtracting {}".format(leftover_in_hex))
                result = locate_two(leftover)
                if result:
                    one.append(result[0])
                    two.append(result[1])
                    three.append(good_char)
                    break
    one = one[::-1] 
    two = two[::-1] 
    three = three[::-1]
    return [one, two, three]



def pad(my_int):
    in_hex = format(my_int, 'x')
    if len(in_hex) == 1:
        return '0'+in_hex
    else:
        return in_hex



def normalise(result):
    print("[*] Got following results")
    print(result)
    
    last = result[2]
    to_return = [ "0x", "0x" ]
    
    if sum(last) is 0:
        for chars in result[0]:
            to_return[0] += pad(chars)
        for chars in result[1]:
            to_return[1] += pad(chars) 
        return to_return
    else:
        to_return.append("0x")
        make_set = set(last)
        make_set.discard(0)
        remainder = make_set.pop()
        array_len = len(last)
        
        for i in range(0, array_len):
            if last[i] == 0:
                to_return[0] += pad(result[0][i] - remainder)
                to_return[1] += pad(result[1][i])
                to_return[2] += pad(remainder)
            else:
                to_return[0] += pad(result[0][i])
                to_return[1] += pad(result[1][i])
                to_return[2] += pad(last[i])
        return to_return




def confirm(values, comparor):
    total = 0
    for i in values:
        total += int(i, 16)
    total_hex = hex(total)
    if total_hex[-8:] == comparor[-8:]:
        print("[*) Confirmed - calculations correct matches {}".format(comparor))
        return True
    print("[*] Calculation wrong for address {}".format(comparor)) 
    return False

def final_process(final_hex, reg='eax'):
    print("[*] Reversing and converting line: {}".format(final_hex.encode('hex')))
    pre_temp = convert_line(final_hex)
    print("[*] Got following address to calculate: {}".format(pre_temp))
    print("[*] Calling pre_process now") 
    temp = pre_process(pre_temp)
    print("[*] Calling normalise now")
    normalised = normalise(temp)
    print("[*] Normalised values : {}".format(normalised))
    if normalised is "MANUALLY":
        return "ERROR with string: ", final_hex


    confirmed = confirm(normalised, pre_temp)
    if not confirmed:
        normalised = ""
        normalised += "*******************\n "
        normalised += "Following address  \n "
        normalised += "couldn't be encoded "
        normalised += final_hex.encode('hex') 
        print normalised
        return []
    xor_1 = "and " + reg + ", 0x554e4d4a"
    xor_2 = "and " + reg + ", 0x2a313235"
    result = [xor_1, xor_2]
    for i in normalised:
        prefix = "sub " + reg + ", " 
        result.append(prefix + i)
    result.append("push " + reg)
    print(normalised)
    return result



def encode(shellcode, reg='eax'):
    print("[*] Shellcode of length {} received".format(len(shellcode)))
    # do some basic input checks here
    quotient = len(shellcode) % 4
    # if quotient > 0:
    #    print("[*] Padding with {} NOPS".format(4-quotient))
    #     shellcode = shellcode + "\x90"*(4-quotient)
    print("[*] Shellcode length is {}".format(len(shellcode)))
    split = [(shellcode[i:i+4]) for i in range(0, len(shellcode), 4)]
    split.reverse() 
    encoded = []
    for i in split:
        x = final_process(i, reg)
        encoded.extend(x)
        print(x)
    print("[*] Finished encoding")
    return encoded



def assemble(assembly, type):
    shellcode = ""
    for line in assembly:
        assembled = asm(line)
        if type == 'shell':
            for char in assembled:
                shellcode += '\\x' + char.encode('hex')
        else:
            shellcode += assembled.encode('hex')
        remainder = len(assembled) % 4
    print("[*] Shellcode length is {}".format(len(shellcode)/4))
    print(shellcode)
    return





if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Feed some shellcode and will encode to a good chararacter set. \n Ensure you manually replace good character set within this file. ')
    parser.add_argument('--reg', default='eax', help='Register to carry out decoding. Default = eax')
    parser.add_argument('--type', default='asm', help='asm for assembly, hex for hex or shell for shellcode. Default is asm')
    parser.add_argument('--good', help='File containing good characters permitted. (good.txt)')  
    parser.add_argument('--input', help='Use $(echo -ne "<paste here>")')
    args = parser.parse_args()
    
    if args.good:
        with open(args.good,'r') as fh:
            good = fh.read()
        print(good[1].encode('hex'))
    else:
        good = generate_good_dict()
  
    if args.type ==  'math':
        print("Math mode enabled. Accepting only an address of 4 bytes in this format 0x11223344")
        address = pre_process(args.input)
        normalised = normalise(address)
        if confirm(normalised, args.input):
            print("[*] All good")
            #print(address)
            print(normalised)
            for i in normalised:
                asm = "sub ", args.reg + ", " + i
                # print("Copy below ************")
                # i# print("# address to be in register 
   
    assembly = None 
    if args.type != 'math':
        assembly = encode(args.input, args.reg )
        if args.type is 'shell' or 'hex':
            assemble(assembly, args.type)
      
    
